# MVCC 多版本并发控制

参考：

+ [15.3 InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html) (官方文档)

+ 《高性能MySQL》P1.4

+ [MySQL - MySQL InnoDB的MVCC实现机制](https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html)



MVCC是为了**提升并发性能**而设计的一种无锁并发控制机制（主要是解决**读-写冲突的无锁并发控制**）。很多数据库都实现了自己的MVCC（暂时没一个统一的实现标准）。

相对于MVCC依靠锁解决并发访问问题的是LBCC（基于锁的并发控制，Lock Based Concurrency Control）。

MVCC可以认为是行级锁的一个变种，但在很多情况下会避免加锁，因此开销更低（典型的有乐观并发机制和悲观并发机制）。

MVCC在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。

InnoDB是一个多版本存储引擎。它保存有关已更改行的旧版本的信息，以支持并发性和回滚等事务性特性。此信息存储在称为回滚段的数据结构中的 undo 表空间中。

> undo表空间包含undo log。



## MySQL MVCC原理

### 前提概念

+ **当前读**

  读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

  如果有更新操作正在执行会等待执行完成。

  如：select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)，串行化事务隔离级别。

+ **快照读**

  像**不加锁的select**操作就是快照读（抽象概念），即**不加锁的非阻塞读**；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制。

+ **数据库并发场景**

  - **读-读**：不存在任何问题，也不需要并发控制

  - **读-写**：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，不可重复读，幻读

    **不可重复读**：一个事务先后读到了其他事务已经修改提交的数据变化；依靠MVCC RR级别下开启事务会立即执行快照读生成ReadView之后都复用这个数据，而RC级别下每次快照读都会重新生成ReadView。

    **幻读**：事务范围查询时读到了其他事务**新增**的数据记录；当前读+RR级别下通过临键锁（行锁+间隙锁）解决；快照读+RR级别下通过MVCC解决的。

  - **写-写**：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

    **更新丢失**：两个事务在并发下同时进行更新，后一个事务的更新覆盖了前一个事务更新的情况。

    **第一类丢失更新**(回滚丢失，Lost update) ，所有数据库都解决了这类问题

    **第二类丢失更新**(覆盖丢失/两次更新问题，Second lost update) ，比如并发修改账户余额先select再update值而不是直接通过++的操作更新。

    MVCC也没有解决第二类丢失更新问题，通常通过开发者自行实现乐观锁（添加版本号字段）解决。

  有了MVCC，数据库并发访问方案形成两个组合：

  - **MVCC + 悲观锁** MVCC解决读写冲突，悲观锁解决写写冲突
  - **MVCC + 乐观锁** MVCC解决读写冲突，乐观锁解决写写冲突

### MySQL MVCC 实现原理

主要由 **2个隐式字段**，**undo日志** ，**Read View** 等实现。

**3个隐藏字段**：

+ DB_ROW_ID 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引
+ **DB_TRX_ID** 6byte, 最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
+ **DB_ROLL_PTR** 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里），用于配合**undo log**，当当前记录对当前事务不可见时，通过undo log 查找对当前记录可见的历史记录版本。

MVCC主要用到**DB_TRX_ID**和**DB_ROLL_PTR**，前者用于可见性比较，后者用于查询对当前事务可见的历史记录。

**undo log** : 

undo log主要分为3种：

- Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。

- **Update undo log**：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。

- Delete undo log

  ：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 

  - 删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。
  - 为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。

对MVCC有帮助的实质是**update undo log** ，undo log实际上就是存在rollback segment中旧记录链。

**ReadVIew**:

Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

包含下面属性：

- trx_ids : 当前系统活跃(`未提交`)事务版本号集合。
- low_limit_id : 创建当前read view 时“当前系统`最大事务版本号`+1”。
- up_limit_id : 创建当前read view 时“系统正处于活跃事务`最小版本号`”
- creator_trx_id : 创建当前read view的事务版本号；

Read View主要是用来做可见性判断的, 判断当前事务能够看到哪个版本的数据，即可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。

**MVCC流程**：

1）对访问目标记录执行快照读，生成一个Read View读视图；

**在RC隔离级别下，是每个快照读（不加锁的select操作）都会生成并获取最新的Read View；**

**在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View**。

2）获取此记录隐藏字段**DB_TRX_ID**的值获取最近一次修改记录的事务ID(已经提交了的)，以及读视图中的活跃事务列表列表trx_list；比较DB_TRX_ID的值与trx_list中活跃事务最小的ID（**up_limit_id**）的值的大小;

小于转3；不小于转4；

3） 小于说明**DB_TRX_ID对应的已提交的事务是当前事务之前的旧事务**，数据版本对当前事务**可见**；当前事务后续的读写等操作在这个版本的数据上进行修改即可；

4）不小于再比较**DB_TRX_ID**的值与读视图的**low_limit_id**（即ReadView生成时刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1）的值的大小;

不小于转5；小于转6;

5）不小于说明**DB_TRX_ID对应的已提交的事务是当前事务之后的新事务**，数据版本对当前事务**不可见**，这时需要通过 undo log 列表查找一条对当前事务可见的历史记录;

6）这时有两种情况：

6.1）**DB_TRX_ID**在读视图的活跃事务列表里面，表示这个版本是由还没提交的事务生成，**不可见**, 需要通过 undo log 列表查找一条对当前事务可见的历史记录;

6.2）**DB_TRX_ID**不在读视图的活跃事务列表里面，表示这个版本是已经提交了的事务生成，**可见**

结合参考资料的示例看更容易理解。

**如下图**（图片来源于参考资料）：

![](/home/arvin/mywork/database/databases/img/db-mysql-mvcc-8.png)

### MVCC 测试

DB_TRX_ID是可以通过SQL命令查看的，不过ReadView 的trx_ids等属性没法看。只能编译启动调试源码。
