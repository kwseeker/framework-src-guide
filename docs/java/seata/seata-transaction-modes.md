# Seata 四种事务模式

|            | AT                                     | TCC                                             | Saga                                                         | XA                             |
| ---------- | -------------------------------------- | ----------------------------------------------- | ------------------------------------------------------------ | ------------------------------ |
| 性能       | 高                                     | 非常高                                          | 非常高                                                       | 低                             |
| 隔离性     | 基于全局锁隔离                         | 基于预留资源隔离                                | 无隔离                                                       | 基于事务完全隔离               |
| 代码侵入性 | 无，补偿（UndoLog）自动生成            | 有，每个操作需要实现三个接口                    | 有，需要编写状态机和补偿                                     | 无                             |
| 一致性     | 弱一致性，也有说最终一致性             | 弱一致性，也有说最终一致性                      | 最终一致性                                                   | 强一致性                       |
| 适用场景   | 基于关系型数据库的大多数分布式事务场景 | 对性能要求高的场景,有非关系型数据库要参与的事务 | 业务流程长且多；<br />参与者包含外部接口或者遗留接口，TCC无法实现 | 对一致性、隔离性要求较高的场景 |

> 关于上面一致性的定义，存疑，很多资料给的答案都不一样，一致性的概念感觉都没有一个很清晰的定义，讨论它到底是什么一致性感觉意义不大。

分析：

+ **TCC AT XA 性能为何依次降低**

  三者都是二阶段提交，它们的性能其实和它们隔离性的实现有关；
  
  TCC 基于预留资源隔离，它仅仅需要在一阶段预留资源时加锁，预留完资源后后续操作和其他全局事务就没有竞争了；

  AT 基于全局锁隔离，比如为了防止脏写（回滚导致的其他事务更新丢失），需要在本地事务写操作时加上全局锁（就是分布式行锁），一个AT全局事务中的全局锁可能包含一组分布式行锁，全局锁在全局事务提交或回滚后释放；AT 相对于 TCC 锁的粒度会大很多；

  XA 基于事务的完全隔离，XA 开启全局事务后全部分支事务都在第二阶段统一提交或回滚，事务的锁也是在提交或回滚后才会释放，锁的粒度也很大，且这里的锁是数据库内部的锁，而 AT 模式的**分布式行锁除了支持DB实现外还支持使用 Redis、Raft实现，相对于DB内部锁性能会更好**；另外由于XA的分支事务持续时间比较长，第一阶段开启第二阶段结束，而**AT模式的本地事务在第一阶段就提交了，相对XA的分支事务更短**，也因为AT模式第一阶段已经提交了，**第二阶段可以异步处理**。
  
  另外看到一种说法：“XA模式相对于AT模式来说，有更多的事务协调和资源管理开销，因此在性能方面可能相对较低”，暂时不清楚这里指的到底是什么，后面有时间梳理XA模式内部流程后再回看这个问题。
  
  
  
  
  
  